== READ THIS NOTE FIRST ==

This is a technology preview release of pkContextCMS. Although the
CMS already works quite well and we are close to launching a production
site based on it, certain aspects are still maturing. In particular
the stylesheet we provide here as a convenience is definitely larger
than the final stylesheet we'll ultimately provide as we haven't had
time to prune it back. 

Also, IE6/IE7 support has not yet been extensively tested. That will
of course happen before a stable release. The editing mechanisms all
work fine in IE (yes, even 6), but there are known CSS issues
at this stage. We're on top of those.

Another issue we haven't tackled in detail yet is internationalization.
We do in fact have the capability to store separate slots by culture,
and we retrieve the appropriate version of a slot for the culture 
of the logged-in user (as determined by setCulture() and getCulture()
on the sfUser object). But we haven't done extensive testing of this
feature. We welcome input from webmasters of internationalized sites.

Enjoy!

= pkContextCMSPlugin =

pkContextCMSPlugin is a CMS (Content Management System) based on the
philosophy that editing should be done "in context" whenever possible.

pkContextCMSPlugin is heavily inspired by, and borrows a little code
and numerous ideas from, sfSimpleCMSPlugin. The changes here are
dramatic enough that a separate plugin makes more sense, but we want
to acknowledge this right up front.

Standard features of pkContextCMSPlugin include version control
for every content slot and the ability to undelete pages, as well as 
in-context editing of all kinds: not just text and rich text editing, 
but also in-context addition, deletion, reordering and retitling of pages. 
When a user is logged in with appropriate privileges, the breadcrumb trail 
and side navigation areas become editing tools, neatly extending the 
metaphors they already implement rather than requiring a second interface
solely for editing purposes. 

pkContextCMSPlugin also introduces "areas," vertical columns in which users 
with editing privileges are able to create more than one slot. This 
makes it easy to interleave text with multimedia and other custom
slot types without the need to develop a custom PHP template for
every page.

== Requirements ==

pkContextCMSPlugin requires:

* Symfony 1.2
* Doctrine
* sfJqueryReloadedPlugin 
* sfDoctrineGuardPlugin
* pkToolkitPlugin 
* PHP 5.2.4 or better with PDO (for Symfony)

pkContextCMSPlugin is compatible with sfShibbolethPlugin (the 1.2 trunk).

Mac users can most easily meet the PHP requirements by installing
the latest version of [MAMP](http://www.mamp.info/). Note that MAMP's PHP 
must be your command line version of PHP, not Apple's default install of PHP. 
To fix that, add this line to the `.profile` file in your home directory:

    export PATH="/Applications/MAMP/Library/bin:/Applications/MAMP/bin/php5/bin:$PATH"

Of course your production server will ultimately need to meet the
same requirements with regard to PHP and PDO.

== Installation ==

For the time being, we recommend that you check out our
sample project via Subversion:

svn co http://svn.symfony-project.com/plugins/pkContextCMSPlugin/cmstest cmstest

Then light that folder up as a virtualhost named cmstest via MAMP, httpd.conf
or whatever your testing environment requires.

This will give you all of the necessary plugins and the ability to
`svn update` the whole shebang with one command.

Then, cd to the `cmstest` folder and run this command:

    ./symfony doctrine:build-all-load

If Symfony complains that the sfCoreAutoload class cannot be found,
you'll need to copy the provided file
config/require-core.php.example to config/require-core.php and edit
the require path in that file to suit your needs. This shouldn't be
necessary if Symfony 1.2 is in your PHP include path.

You can now log in as `admin` with the password `admin` to see how the
site behaves when you're logged in. Start adding subpages, editing
slots, adding slots to the multiple-slot content area... have a ball with it
and send your comments to `tom@punkave.com`.

That's the easy way. The notes that follow assume you're doing it 
the hard way. (: 

* * *

Install the above plug-ins in your Symfony 1.2 project. Since you are
almost certainly using svn externals to fetch the plugins,
be sure to create the necessary symbolic links from your projects web/ folder 
to to the web/ folders of the plugins that have one. For best results use
a relative path:

    cd web
    ln -s ../plugins/pkContextCMSPlugin/web pkContextCMSPlugin
    # Similar for other plugins required

Create an application in your project. Then create a
module folder named pkContextCMS as a home for your page templates
and layouts (and possibly other customizations):

    mkdir -p apps/frontend/modules/pkContextCMS/templates

The CMS provides convenient login and logout links. By default these
are mapped to sfGuardAuth's signin and signout actions. If you are
using sfShibbolethPlugin to extend sfDoctrineGuardPlugin, you'll
want to change these actions in apps/frontend/config/app.yml:

all:
  sfShibboleth:
    domain: duke.edu
  pkContextCMS:
    actions_logout: "sfShibbolethAuth/logout"
    actions_login: "sfShibbolethAuth/login"

You will also need to enable the pkContextCMS modules in 
your application's `settings.yml` file. Of course you may need
other modules as well based on your application's needs:

    enabled_modules:        [pkContextCMS, pkContextCMSText, pkContextCMSRichText, sfGuardAuth]

Load the fixtures for the "stub" site. Every site begins with a home
page with all other pages being added as descendants of the home page:

    ./symfony doctrine:build-all-load

By default pkContextCMS will establish routes which map your modules and 
actions to:

/cms/modulename/actionname

And check all other URLs to see whether they match a slug (i.e. a path)
in the CMS, offering up that page via the pkContextCMS/show action if so.

If this is not what you want, you will need to shut off the built-in
routes via app.yml and write your own:

    pkContextCMS_routes_register: false

In any case, it is up to you to provide a route for the homepage of
your site. If you want the homepage to be the root page of the CMS,
just use this route in your routing.yml file:

    homepage:
      url:   /
        param: { module: pkContextCMS, action: show, slug: / }

Finally, to get the benefit of the progressively enhanced form controls
featured in our admin tools, you'll need to add pkToolkitPlugin's
pkControls.js to your view.yml file:

    default:
      ... Other things ...
      javascripts:    [/pkToolkitPlugin/js/pkControls.js]

== Routing Rules ==

For compatibility reasons, by default your CMS pages will appear in the /cms "folder"
of your site. That is, the "home page" is `http://yoursite.com/cms`. Administrative
actions of the CMS can then use the default Symfony routing rules. The home page URL ("/") is not overridden
by default and still goes wherever you'd like it to go in your application.

Of course, this probably isn't what most people want in practice. You can easily
customize it via your `routing.yml` file so that URLs are presumed to be CMS pages if they do 
not expressly match a routing rule. And it's not hard to create a catch-all "folder" to contain URLs mapped to Symfony actions rather than CMS pages.

These rules are used by our `cmstest` project. Note that the routing rule for pages must be named `pk_context_cms_page` so that the plugin can use it explicitly to generate short paths to pages, even in the presence of the default rule which would otherwise match first:

    # This default routing rule handles all non-CMS actions that are not
    # explicitly routed by another rule

    default:
      url:   /admin/:module/:action/*

    # A homepage rule is expected by pkContextCMS and various other plugins,
    # so be sure to have one

    homepage:
      url:  /
      param: { module: pkContextCMS, action: show, slug: / }

    # Put any additional routing rules for other modules and actions HERE,
    # before the catch-all rule that routes URLs to the
    # CMS by default.

    # Must be the last rule, and must have this name

    pk_context_cms_page:
      url:   /:slug
      param: { module: pkContextCMS, action: show }
      requirements: { slug: .* }

When using this technique you will also need to turn off the default routing rules of the CMS
as we've done in the `cmstest` project:

    all:
      pkContextCMS:
        routes_register: false

Thanks to Stephen Ostrow for his analysis of this issue.

== Customizing Your CMS Site ==

You now have a CMS site. Access your Symfony site's URL to see the
home page. 

Click "log in" and log in as the sfDoctrineGuard superuser 
(admin/admin) to see
the editing controls.

=== Managing Pages ===

When a user has editing privileges on a page, they are able to make
the following changes via the breadcrumb trail, which becomes an
interactive site management tool when logged in:

* Rename the page by clicking on the page title
* Add a child page beneath the current page
* Open the page management settings dialog via the "gear" icon
for less frequent changes

Note that the breadcrumb trail appears on the home page only when
logged in with editing privileges. On sub-pages the breadcrumb
trail always appears.

Deletion of a page is not permanent. Anonymous users, and users who do not
have editing privileges on the page, will see the usual 404 Not Found error.
But users with editing privileges will see the page with its title
"struck through" and will be able to undelete the page if they desire.

The side navigation column also offers an editing tool: users with
editing privileges can change the order of child pages listed there
by dragging and dropping them. (If a page has no children, the side
navigation displays its peers instead, including itself.)

=== Editing Content: Editing Slots ===

What about the actual content of the page? The editable content
of a page is stored in "CMS slots" (not the same thing as Symfony slots).
CMS slots can be of several types:

* Plaintext slots (single line or multiline)
* Rich text slots (edited via FCK)
* Custom slots (of any type, implemented as described later)

Once you have logged in, you'll see each editable slot outlined
with a box. If the slot is currently empty, there will also be a 
hint to double-click the slot to begin editing it. Double-click it to
edit it with the appropriate editor (an input, textarea or rich
text edit control). Click "Save" to save your changes.

Every slot also offers version control. The arrow-in-a-circle icon
accesses a dropdown list of all changes that have been made to that slot,
labeled by date, time and author. Pick any version and click "Preview"
to redisplay that version of the slot. To revert to an old version,
copying it to create a new version of the slot, click "Revert." Click
"Cancel" if you decide not to switch versions.

=== Editing Content: Editing Areas ===

In addition to single slots, pkContextCMSPlugin also supports
"areas." Areas are vertical columns containing more than one slot.
Editing users are able to add and remove slots from an area at any time, 
selecting from a list of slots approved for use in that area. The slots
can also be reordered via up and down arrow buttons (used here instead
of drag and drop to avoid possible browser bugs when dragging and dropping 
complex HTML).

The usefulness of areas may not be entirely clear when only 
plaintext and rich text slots are in use on a site. Their usefulness
can be better understood when custom slot types that implement
multimedia or connect to your project-specific resources come into play.
You want to be able to interleave these with blocks of text without
creating a new custom page template for each one. Areas give you that
capability.

== Creating and Managing Page Templates and Layouts ==

Where do slots appear in a page? And how do you insert them? 

Slots can be inserted in two places: in your site's <tt>layout.php</tt>
file, which decorates all pages, and in page template files, which can
be assigned to individual pages. 

=== How to Customize the Layout ===

By default, the CMS will use the
<tt>layout.php</tt> file bundled with it. If you wish, you can turn this
off via app.yml:

    all:
      pkContextCMS:
        use_bundled_layout: false

CMS pages will then use your application's default layout. One strategy
is to copy our <tt>layout.php</tt> to your application's template folder
and customize it there after turning off use_bundled_layout.

=== Turning Off the Home Page Tab ===

By default pkContextCMS generates navigation tabs for the direct
children of the home page, and for the home page itself. If you don't
want a tab for the home page itself, just change this setting
in `app.yml`:

    all:
      pkContextCMS:
        home_as_tab: false

=== Reordering Children of the Home Page ===

pkContextCMS offers drag-and-drop reordering of the children of
any page via the navigation links on the left-hand side. But the home
page, by default, doesn't display those links. So how can you reorder
its children?

One way is to add the subnav component back into your
local copy of homeTemplate.php:

    <?php include_component('pkContextCMS', 'subnav') # Left Side Navigation ?>

To avoid wrecking the layout of your home page, you could choose to 
insert it only when an admin is logged in:

    <?php if ($sf_user->hasCredential('cms_admin')): ?>
      <?php include_component('pkContextCMS', 'subnav') # Left Side Navigation ?>
    <?php endif ?>

On our "TODO" list: allow the left side navigation controls to be collapsed
by default for more convenient use on pages with a layout that doesn't
really accommodate them.

=== How to Customize the Page Templates ===

The layout is a good place for global elements that should appear on
every page. But elements specific to certain types of pages are better
kept in page templates. These are standard Symfony template files with
a special naming convention.

Page template files live in the templates folder of the pkContextCMS module. 
We provide these templates "out of the box:"

* homeTemplate.php
* defaultTemplate.php

homeTemplate.php is used by our default home page, and defaultTemplate.php
is the default template if no other template is chosen.

You can change the template used by a page by using the
template dropdown in the breadcrumb trail. This does not delete
the slots used by the previous template, so you can switch back
without losing your work.

How do you create your own template files? *Don't* alter the templates
folder of the plugin. As always with Symfony modules, you chould 
instead create your own pkContextCMS/templates folder within your
application's modules folder:

    mkdir -p apps/frontend/modules/pkContextCMS/templates 

Now you can copy homeTemplate.php and defaultTemplate.php to this folder,
or just start over from scratch. You can also copy _login.php if you don't
like the way we present the login and logout options. The same applies
to _tabs.php. We *do not recommend* altering the rest of the templates unless 
you have a clear understanding of their purpose and function and are
willing to make ongoing changes when new releases are made. In general,
if you can use CSS to match the behavior of our HTML to your needs,
that will be more forwards-compatible with new releases of the CMS.

If you add additional template files, you'll need to adjust
the `app_pkContextCMS_templates` setting in `app.yml` so that your
new templates also appear in the dropdown menu:

    all:
      pkContextCMS:
        templates:
          home:
            Home Page
          default:
            Default Page
          mytemplate:
            My Template

=== Inserting Slots in Layouts and Templates ===

Of course, creating layouts and templates does you little good if you
can't insert user-edited content into them. This is where the 
CMS slot helpers come in.

Here's how to insert a slot into a layout or page template:

    <?php # Once at the top of the file ?>
    <?php use_helper('pkContextCMS') ?>
    
    <?php # Anywhere you want a particular slot ?>
    <?php pk_context_cms_slot('body', 'pkContextCMSRichText') ?>

Notice that two arguments are passed to the <tt>pk_context_cms_slot</tt>
helper. The first argument is the name of the slot, which distinguishes
it from other slots on the same page. *Slot names should contain only
characters that are allowed in HTML ID and NAME attributes*. We recommend
that you use only letters, digits, underscores and dashes in slot names.
The slot name will never be seen by the user. It is a useful label
such as `body` or `sidebar` or `subtitle`.

The second argument is the type of the slot. "Out of the box," 
pkContextCMSPlugin offers two slot types:

* pkContextCMSRichText
* pkContextCMSText

You can add additional slot types of your own and release and
distribute them as plugins as explained later in this document.

The special slot name `title` is reserved for the title of the page
and is always of the type `pkContextCMSText`. 
While you don't need to provide an additional editing interface
for the title, you might want to insert it as an `h1` somewhere in your
page layout or template as a design element:

    <h1>
        <?php pk_context_cms_slot('title', 'pkContextCMSText',
          array('toolbar' => 'basic')) ?>
    </h1>

The behavior of most slot types can be influenced by passing 
options to them from the template or layout. 
You can also pass an array of options as a third argument
to the helper, like this:

    <h2>
        <?php pk_context_cms_slot('subtitle', 'pkContextCMSRichText',
          array('toolbar' => 'basic')) ?>
    </h2>

Here we create a subtitle area on the page which is editable, but only
with the limited palette of options provided in FCK's `basic` toolbar.
This works because the `pkContextCMSRichText` slot implementation calls
the `textarea_tag` helper, passing the options array along. (These
options are also available to the slot implementation at the time
the slot is saved, which will be discussed in more detail later.)

Incidentally, you can create your own custom toolbars for FCK as part
of your FCK configuration. See the FCK documentation. Note that this
does not actually prevent the user from submitting other HTML, often
by copying and pasting from Microsoft Word, etc. We plan to include
connectors to an HTML tidying package in a future release of the CMS to reduce
the severity of this problem.

In addition to passing familiar options along to the 
`input_tag` and `textarea_tag` helper functions, you can
also pass the `multiline` option when inserting a slot 
of the type `pkContextCMSText`. When `multiline` is true, the
plaintext slot is rendered with `textarea_tag` rather than
`input_tag`.

=== Inserting Areas: Unlimited Slots in a Vertical Column ===

Slots are great on their own. But when you want to mix paragraphs of text with
elements inserted by custom slots, it is necessary to create a separate
template file for every page. This is tedious and requires the
involvement of an HTML-savvy person on a regular basis.

Fortunately pkContextCMSPlugin also offers "areas." An
area is a continuous vertical column containing multiple slots which
can be managed on the fly without the need for template changes. 

You insert an area by calling pk_context_cms_include_area($name) rather than
pk_context_cms_include_slot($name):

    <?php pk_context_cms_include_area("sidebar") ?>

When you insert an area you are presented with a slightly different
editing interface. At first there are no editable slots in the area.
Click "Insert Slot" to add the first one. You can now edit that
first slot and save it.

Add more slots and you'll find that you are also able to delete them
and reorder them at will.

An area has just one version control button for the entire area. This
is because creating, deleting, and reordering slots are themselves
actions that can be undone through version control.

In a project with many custom slot types, you may find it is 
inappropriate to use certain slot types in certain areas. You can
specify a list of allowed slot types like this:

    <?php pk_context_cms_include_area("sidebar",
      array("allowed_types" => array("pkContextCMSText", "myCustomType"))) ?>

Notice that the second argument to `pk_context_cms_include_area` is an
associative array of options. The `allowed_types` option allows us to
specify a list of slot types that are allowed in this particular area.

In addition, you can pass options to the slots of each type, much as
you would when insertin a single slot:

    pk_context_cms_include_area("sidebar",
      array("allowed_types" => array("pkContextCMSText", "myCustomType"),
        "type_options" => array(
          "pkContextCMSText" => array("multiline" => 1))));

Here the `multiline` option specifies that all 
`pkContextCMSText` slots in the area should have the
`multiline` option set.

=== Inserting the Breadcrumb Trail and Side Navigation ===

Your layout, or possibly your page templates if you wish to handle
it differently on some pages, will need to insert the breadcrumb
trail and side navigation elements on some or all pages.

The breadcrumb trail is inserted into a page template or layout
by the following code:

    <?php include_component('pkContextCMS', 'breadcrumb') ?>

Sometimes, such as on the home page, you do not want to display the breadcrumb 
trail at all, when the user is not logged in. But you still need it when you 
are are logged in so that you can manage the page. You can handle
this situation like so:

    <?php if (pkContextCMSTools::getCurrentPage()->userHasPrivilege('edit')): ?>
      <?php include_component('pkContextCMS', 'breadcrumb') ?>
    ?>

The side navigation column ("subnavigation") is inserted similarly:

    <?php include_component('pkContextCMS', 'subnav') ?>

== Global Slots ==

Most of the time, you want the content of a slot to be specific to a page.
After all, if the content was the same on every page, you wouldn't need
more than one page.

However, it is sometimes useful to have editable content that appears
on more than one page. For instance, an editable page footer or page 
subtitle might be consistent throughout the site, or at least throughout
a portion of the site.

You can do this by adding a "global slot" to your page template or layout.
Just set the `global` option to `true` when inserting the slot:

    <h4>
        <?php pk_context_cms_slot('footer', 'pkContextCMSRichText',
          array('toolbar' => 'basic', 'global' => true)) ?>
    </h4>

The content of the resulting slot is shared by all pages that include
it with the `global` option.

Note that global slots can be edited only by users with editing
privileges throughout the site. Otherwise users with control only over
a subpage could edit a footer displayed on all pages.

Have a need for a slot that is shared by some pages, but not all pages?
Just name the slot appropriately. For instance, the slot name
`chemistry-blurb` might be suitable for all pages in the
chemistry department of an educational institution's website.

== Overriding the Stylesheets ==

By default, `pkContextCMSPlugin` provides two stylesheets which are
automatically added to your pages. There's a lot happening there,
particularly with regard to the editing interface, and we recommend
that you keep these and override them as needed in a separate
stylesheet of your own. However, you can turn them off if you wish
in `app.yml`:

    all:
      pkContextCMS:
        use_bundled_stylesheet: false

If you do keep our stylesheets and further override them, you'll
want to specify `position: last` for the stylesheets that should
override them.

== Access Control ==

By default, a pkContextCMS site follows these security rules:

* Anyone can view any page without being authenticated.
* Any authenticated (logged-in) user can edit any page.

This is often sufficient for simple sites. But pkContextCMS can
also handle more complex security needs.

=== Requiring Login to Access All Pages ===

To require that the user log in before they view any page
in the CMS, use the following setting in `app.yml`:

    all:
      pkContextCMS:
        view_login_required: true

=== Requiring Login to Access Some Pages ===

To require the user to log in before accessing a particular page,
just navigate to that page as a user with editing privileges
and click on the "lock" icon. Locked pages are only accessible
to logged-in users.

=== Requiring Special Credentials to Edit Pages ===

Editing rights can be controlled in several ways:

1) Any user with the `cms_admin` credential can always
edit, regardless of all other settings. Note that the
sfGuard "superadmin" user always has all credentials.

2) Any user with `edit_sufficient_credentials` can always edit
anywhere on the site. For instance, if you add such users
to the `executive_editors` sfGuardGroup and grant that group
the `executive_editors` permission, then you can give them
full control of the CMS with these settings:

    all:
      pkContextCMS:
        edit_sufficient_credentials: executive_editors

3) Any user who is a member of the group specified by
`edit_group` can *potentially* be made an
editor in particular parts of the site. If
`edit_group` is not set, all users are
potential editors: 

    all:
      pkContextCMS:
        edit_group: editors

Why is this feature useful? Two reasons: because checking their membership
in one group is faster than checking their access privileges in the
entire chain of ancestor pages, and because when an administrator is
managing the list of users permitted to edit a page the list of users in the
editors group is less unwieldy than a list of all users.

4) Editing privileges for any specific page and its descendants
can be granted to any member of the group specified by 
`app_pkContextCMS_edit_group` (if that option is set), or to
any user if `app_pkContextCMS_edit_group` is not set.
When a user with the `cms_admin` credential clicks on the "lock" icon, 
they are given the option of assigning editors for that page. 

Note that the pulldown list of possible editors can be quite long
if there are thousands of people with accounts on your site! This
is part of why we offer the `edit_group` feature.
To take advangage of it, add all potential editors to an sfGuardGroup, 
give that group a permission named `editors`, and set 
`edit_sufficient_credentials` to `editors`. Now the dropdown list will
display only the members of the `editors` group.

=== On/Off: Hiding Pages, by Choice and By Default ===

pkContextCMS offers an "on/off" toggle under "manage page settings."
Pages that are turned off are completely invisible to users who do not
have editing credentials for them; a user without appropriate privileges
gets a 404 not found error just as if the page did not exist. In most cases
you should use this in preference to actually deleting the page because the
content is still available if you choose to bring it back later.

By default all new pkContextCMS pages are in the "on" state.
If you need to approach the matter more conservatively, you can easily
change this with the following `app.yml` setting:

    all:
      pkContextCMS:
        default_on: false

== Creating Custom Slot Types ==

You are not limited to the two slot types provided with
pkContextCMSPlugin! Anyone can create new slot types by taking
advantage of normal Symfony features: modules, components,
actions, templates and Doctrine model classes.

Let's look at `pkContextCMSText` to understand how this works.

The `pkContextCMSText` slot type is implemented as follows:

1) *The model class.* Every slot must be stored in the database. 
All slot types have a model class which inherits from 
`pkContextCMSSlot`. The `pkContextCMSText` model class is
`pkContextCMSTextSlot`.

This is done using a feature of Doctrine called
*column aggregation inheritance*. Column aggregation inheritance
allows you to gain the benefits of object-oriented inheritance
while still storing all of the slot types in the same database table.
Doctrine manages this automatically for you.

The relevant portion of `config/doctrine/schema.yml` for
`pkContextCMSText` looks like this:

    pkContextCMSTextSlot:
      inheritance:
        extends: pkContextCMSSlot
        type: column_aggregation
        keyField: type
        keyValue: 'pkContextCMSText'

The `extends` keyword specifies the class we are inheriting from, while
the `keyValue` field must contain the name of the type. Doctrine uses
this to figure out what class of object to create when loading a 
record from the `pk_context_cms_slot` table. The slot type name name is
recorded in the `type` column. You don't need to worry
about the details, but for more information about them,
see the excellent Doctrine documentation.

*Yes, you can have custom columns in the database for your type.*
A plaintext slot doesn't need them because the `value` column works
well for storing its contents. But you can add whatever columns
suit your purposes. For example, a `pkContextYoutube` slot type might
have a model class schema like this:

    pkContextYoutubeSlot:
      inheritance:
        extends: pkContextCMSSlot
        type: column_aggregation
        keyField: type
        keyValue: 'pkContextCMSYoutube'
      columns:
        youtube_url: string(300)
        youtube_auto_repeat: boolean

Note that I have prefixed the extra columns with `youtube_`. This is
required if you intend to release your slot type as a plugin because
collisions between column names intended for use in different slot types
can cause problems for other users. If your slot type is strictly for
use in your own project, then you can get by without a prefix. It would
be nice if Doctrine did this automatically so that the field names
of subclasses were never really in conflict, but so far it does not.

(You may be able to work around this issue with less typing by using 
Doctrine's "name: phpname as sqlname" syntax. But I have not yet tested this
to see how it interacts with column aggregation inheritance. 
TODO: find out! If you try it, let me know.)

Any columns that you add to your custom slot type are automatically
included in the definition of `pk_context_cms_slot` when the
SQL for your database is generated by the `doctrine:build-all`
or `doctrine:build-sql` task.

2) *The module.* Every slot type is implemented by a Symfony module of
the same name. The `pkContextCMSText` slot type is implemented by the
`pkContextCMSText` module. Create your own modules for your own
custom slot types. However, you'll set up your actions, components and
templates in a specific way as described below.

3) *The components class.* The `pkContextCMSText` slot type's
component clas is called `pkContextCMSTextComponents`. Unlike 
typical components classes it inherits from
`pkContextCMSBaseComponents`:

    class pkContextCMSTextComponents extends pkContextCMSBaseComponents

This class typically contains two components, although the
base class versions inherited from pkContextCMSBaseComponents are
sometimes sufficient to do the job, depending on the behavior you want:

* The `normalView` component. The `normalView` component displays
your slot as a normal user, not a user with editing privileges,
would see it. The default implementation simply outputs the
contents of of the `value` column of the slot as HTML, which works for
both `pkContextCMSRichText` and `pkContextCMSText` (the latter stores
its "plaintext" pre-escaped to be displayed as HTML).

If you choose to change this behavior, you'll need to code the 
`execute` method like so. Note the use of the
`$this->setup()` method, which automatically sets up 
the slot object for you as well as various other conveniences:

    public function executeNormalView()
    {
      // Sets up $this->slot, $this->name, $this->id, etc. automatically
      $this->setup();
      // Examine options with $this->getOption('optionname'), set
      // various member variables for convenience in the partial, etc.  
    }

The corresponding partial, `_normalView.php`, could look like this:

    <?php if (!strlen($value)): ?>
      <?php if ($editable): ?>
        Double-click to edit.
      <?php endif ?>
    <?php else: ?>
    <?php echo $value ?>
    <?php endif ?>

Even though this is the non-editing view (displayed even to editors until
they double-click), the `editable` parameter is set as a convenience so that 
you can determine that the user does have editing privileges.

* The `editView` component. The `editView` component displays your
slot with appropriate editing controls. You can use Symfony 1.2-style
form classes, but you are not required to. 

The `executeEditView` method for `pkContextCMSText' looks like this:

    public function executeEditView()
    {
      $this->setup();
      $this->multiline = $this->getOption('multiline');
      // The rest of the options array is passed as HTML
      // options to the helper function, but this
      // should not be
      unset($this->options['multiline']);
    }

And the corresponding template, `_editView.php`, looks like this:

    <?php if ($multiline): ?>
      <?php echo textarea_tag("value",
        $value,
        array_merge(array("id" => "$id-value"), $options)) ?>
    <?php else: ?>
      <?php echo input_tag("value",
        $value,
        array_merge(array("id" => "$id-value"), $options)) ?>
    <?php endif ?>

Note the use of the `$id` variable. This variable is guaranteed to
make an ID unique among all of the slot editing forms that may be
present on the page at any given time. Be sure to take advantage
of `$id` rather than second-guessing the process by inserting
`$name` and `$permid` yourself.

A Symfony 1.2 forms-based implementation of the 
executeEditView method looks like this. Note that we don't
always have to create a new form object! When the user's first
attempt to fill out the form results in a validation error,
the form object is automatically restored to `$this->form`.
When you output that form object again, the validation errors
are displayed just as they would be if you were using
ordinary action templates. Neat and tidy.

Since Symfony generates form fields with ID attributes,
it is necessary to set the form's name format in a way that
will not conflict with other slot editing forms hidden in
the page. This is the purpose of the `setId()` call below.
Don't worry, you'll see the form class code that
implements that method in a moment.

    public function executeEditView()
    {
      $this->setup();
      // If there is already a form object reuse it! It contains
      // validation errors from the user's first attempt to submit it.
      if (!isset($this->form))
      {
        $this->form = new FvtestForm();

        // Be sure to show the current value. 

        $this->form->setDefault('count', $this->slot->value);

        // Necessary to prevent HTML id collisions between multiple slots
        // on the same page (see the setId method of the FvtestForm class)
        $this->form->setId($this->id);
      }
    }

You'll note that we explicitly call `setDefault` to redisplay the
current value of the slot. This raises an interesting question: if
we were taking full advantage of column aggregation inheritance
by using the Doctrine form that Symfony auto-generates for our
slot model class, could we skip this step and also avoid the
need to create our own form class?

Unfortunately, as of this writing the answer is no. Doctrine
column aggregation inheritance is a beautiful thing, but it doesn't
currently generate good forms. That's because the forms generated
for the subclasses contain *all* of the fields for *all* of the
subclasses. Obviousy, that's not desirable. So build your own
form classes to edit your custom slot types... like this one:

    class FvtestForm extends sfForm
    {
      public function configure()
      {
        $this->setWidgets(array(
          "count" => new sfWidgetFormInput(array())
        ));
        $this->setValidators(array(
          "count" => new sfValidatorInteger(array(
            'min' => 10, 'max' => 20, 'required' => true))));
        $this->widgetSchema->setFormFormatterName('table');
      }
      public function setId($id)
      {
        $this->widgetSchema->setNameFormat("Fvtest-$id" . "[%s]");
      }
    }

Note the `setId()` method which takes care of ensuring that each form
field has an ID attribute that is unique throughout the document.

The corresponding `_editView.php` template is as follows
(very simple indeed):

    <table>
    <?php echo $form ?>
    </table>

But how does the form get bound and saved? That's the topic of
the next section.

4) *The actions class.* The `pkContextCMSText` slot type's action
class is called `pkContextCMSTextActions`. Unlike most action classes,
it inherits from `pkContextCMSBaseActions`, like so:

    class pkContextCMSTextActions extends pkContextCMSBaseActions

Our `pkContextCMSTextActions` class must contain at least
one action, the edit action. This action is invoked when the user clicks
"save" after editing the slot. 

The `pkContextCMSBaseActions` class provides two private methods that
help you code `executeEdit` correctly: 

* `editSetup`, which locates the appropriate options for the slot and loads 
or creates a slot object.
* `editSave`, which does the hard work of managing version
control while saving the slot. 

Call `$this->editSetup()` at the beginning of your `executeEdit` method,
and *return the result* of `$this->editSave()` at the end. If the user's
input is unacceptable and you want them to try again, 
*return the result* of a call to `$this->editRetry()` instead.

In between, all you have to do is look at the appropriate 
request parameters provided by your `_editView.php` template and
set the appropriate fields of `$this->slot`. You can store your data in 
`$this->slot->value` if a variable-length string suits all of your needs
(as it often does, especially with PHP's `serialize()` and unserialize()`).
Or you can use the custom fields you defined when designing the schema
for your model class. This has the advantage that you can more easily
look for that information via database queries later. 

For instance, for the Youtube slot mentioned earlier:

    public function executeEdit(sfRequest $request)
    {
      $this->editSetup();
      $url = $this->getRequestParameter('url');
      $autorepeat = $this->getRequestParameter('auto_repeat');
      $this->slot->youtube_url = $url;
      $this->slot->youtube_autorepeat = $autorepeat;
      // Note that we must return the result!
      return $this->editSave();
    }

The Symfony 1.2 forms approach is similar. Note that we once
again take advantage of the `setId()` method we added to our
form class earlier. We also need to take the unique ID of the
slot form into account when calling `bind()`:

    public function executeEdit(sfRequest $request)
    {
      $this->editSetup();
      $this->form = new FvtestForm();
      $this->form->setId($this->id);
      $this->form->bind($request->getParameter("Fvtest-" . $this->id));
      if ($this->form->isValid())
      {
        $this->slot->value = $this->form->getValue('count');
        return $this->editSave();
      }
      else
      {
        // Automatically passes $this->form on to the 
        // next iteration of the edit form so that
        // validation errors can be seen
        return $this->editRetry();
      }
    }

To simplify validation, `$this->form` is automatically
provided to the `editView` component when you call `editRetry()`, 

=== Beyond edit: Additional Actions ===

Note that your actions class may contain other actions if you wish. Typically
these are AJAX actions and other auxiliary actions that share the work
of editing the slot object. 

You may also have actions that perform AJAX updates of the normal, non-editing
view of the slot.

In these cases, you may need to be able to retrieve the slot again and
refresh a portion of your display. For actions that modify the slot,
you can just call `this->editSetup()` to get all of the necessary parameters
and initialize `$this->slot`. But what about actions that don't modify
the slot but nevertheless need to access its contents? Such actions
can call `$this->setup()` instead. The `setup()` method is equivalent
to `editSetup()`, except that it allows access by users who do not have
editing privileges unless you expressly pass the value `true` for the
`$editing` parameter. (It does check for view access.)

=== Custom Validation ===

Sometimes `$this->form` isn't enough to meet your needs. You might
have more than one Symfony 1.2 form in the slot (although you should
look at `embedForm()` and `mergeForm()` first before you say that). 
Or you might not be using Symfony 1.2-style forms at all.

Fortunately there's a way to pass validation messages from the 
`executeEdit` action to the next iteration of the `editView` component:

    // Set it in the action
    $this->validationData['custom'] = 'My error message';

    // Grab it in the component
    $this->error = $this->getValidationData('custom');

    // ... And display it in the template
    <?php if ($error): ?>
      <h2><?php echo $this->error ?></h2>
    <?php endif ?>

Note that `$this->validationData['form']` is used internally
to store `$this->form`, if it exists in the action. So we suggest
that you use other names for your validation data fields.

=== Overriding the Outline Box and Double-Click Behavior ===

By default, when a user with editing privileges is viewing a slot,
the slot has an outline box and can be double-clicked to display
the editing view. 

This works well for many slot types but might not be appropriate
for yours. If you wish to implement a different behavior for switching to
the editor, such as an "Edit" button, just add this method to
your slot's model class:

    public function isOutlineEditable()
    {
      return false;
    }

This will turn off the "double-click to edit" behavior and outline box.

You can replace this with the following or similar in your
`_normalView.php` template:

<?php if ($editable): ?>
  <?php echo button_to_function('Edit', $showEditorJS) ?>
<?php endif ?>

Note that `$showEditorJS` comes preloaded with ready-to-run JavaScript code 
to hide the normal view and display the editing view. 

You can also turn off the outline box for a particular insertion of a slot
by padding the `outline_editable` option to the slot helper with 
a value of `false`. Explicit settings for this option override 
what is returned by the `isOutlineEditable` module.

=== When You Don't Want an Inline Editor ===

Most of the time, inline editors are great. But sometimes you might be
happier with a full-page interface which eventually redirects back
to pkContextCMS when the work is done. In such cases you'll want to 
display a link to that editor in the normal view template when the user
has editing privileges. To make that work, just link to your
standalone editor page like this:

    <?php if ($editable): ?>
      <?php echo link_to("Edit This", "http://my/editor/page") ?>
    <?php endif ?>

Then, when the editing is complete, your editor will need to return
the information to pkContextCMS by redirecting the browser
or POSTing a form to a URL constructed like this:

    url_for("yourSlotModuleName/edit?" . http_build_query(
      array(
        "name" => $name,
        "slug" => $slug,
        "permid" => $permid,
        "noajax" => 1)))

The easiest way to accomplish this is to pass the complete edit-action
URL as a parameter when linking to your external editor. This code
demonstrates how we do it for our own pkContextMediaSlot, which
integrates with pkMediaPlugin without the need for any 
CMS-specific code in pkMediaPlugin:

    <?php if ($editable): ?>
      <?php echo link_to('Choose media',
        sfConfig::get('app_media_site', false) . "pkMedia/select?" .
          http_build_query(
            array("multiple" => true,
            "after" => url_for("pkContextCMSMedia/edit?" .
              http_build_query(
                array(
                  "name" => $name,
                  "slug" => $slug,
                  "permid" => $permid,
                  "noajax" => 1))))),
        array('class' => 'pk-context-button')) ?>
    <?php endif ?>

Note the use of the `noajax` parameter. This suppresses the 
usual "refresh the slot without refreshing the whole page" behavior,
which is not appropriate after we've already left the page to
display an external editing page. When `noajax` is set,
the user is redirected to the updated page instead. This is
described in more detail in the next section.

You'll also want to turn off the "double-click to edit" behavior that
would otherwise open the inline editor, as explained in the
previous section.

=== When You Don't Want AJAX ===

Normally pkContextCMS displays the updated contents of the slot without
refreshing the entire page. If this is unsuitable for your purposes,
as will be the case if you are not using an inline editor,
then just include a <tt>noajax</tt> parameter in the request received by
your edit action, with a value of 1. The edit action will then 
redirect to the updated page rather than attempting to refresh
only the updated slot. 

== Changelog ==

=== Version 0.14 ===

Another fix to the routing rules of the `cmstest` project. The Symfony
default routing rule isn't really compatible with mapping the
CMS to the root of the site: it breaks all grandchild pages. We deal
with this by prefixing the default routing rule with /admin. So 
for a simple routing system without a lot of explicit rules for
individual actions and modules, either the (a) CMS pages or (b) everything else
must be distinguished by a prefix in the URL. The default rules
prepended by the plugin take the former approach, while the cmstest
project demonstrates the latter. 

You can of course write explicit routing rules
for individual Symfony actions and modules that result in nicer URLs for
those particular actions and modules. That combines well with the
second approach.

=== Version 0.13 ===

Fixed routing rules of `cmstest` project. Renamed
the `pk_context_cms_page` rule and instituted the use of 
`@pk_context_cms_page` in the URL generation method to route to it even 
if the default routing rule would otherwise match `pkContextCMS/show` first.

=== Version 0.12 ===

Default routing rules no longer try to override the root
of the site. Instead we demonstrate how to do that in the 
`routing.yml` file of the `cmstest` project.

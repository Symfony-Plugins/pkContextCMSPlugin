Notes from testers:

Shim the test login somehow. Or just log them in initially.
Didn't understand what "add page" meant, typed a URL (to link to?)
  rather than a title for a subpage.
* Then she ran into the "delete button is missing" bug, which I fixed.

POST should beat URL parameters and GET.

Implement "unpublished/published/deleted" tristate.

* A way to handle edit validation errors (including Symfony 1.2 forms style!)
  in the CMS.

Tristate: unpublished, published, deleted. Unpublished pages
show up grayed out. New pages are unpublished by default.
Deleted pages can be hidden to avoid clutter when browsing
as an editor.

X Consider separating the one-line and multiline slot types or providing
  a way to offer a slot type under multiple configurations

UI to alter slugs and create a landing page.

* Implement slug editing.
* Landing pages with altered slugs.
* Make all the security rules actually work.
* Sufficient credentials
* Page credentials
* Inherited page credentials
* Global can only be edited by those with the 'sufficient credentials'
* Page locking
* Required group
* Figure out why drag and drop reordering is broken. (stray bad js
  in john's code, call to nonexistent console)


* Ability to specify which slots are valid in which areas via option passing

* Make sure you can pass options to individual slot types in areas

* All-lowercase slugs with dashes

* UI to initially select and later change the template for a page.

* Figure out how $this->multiline is working even though it seems
like it shouldn't

* Stop passing multiline to the actual textarea tag


* View access control (just "logged in or not logged in").

* Global Slots

* Hide history on history cancel

* Hide type selector and buttons after add of slot is completed

* Schema overhaul

* What happened to delete page?

* Make sure copy() behaves properly for column aggregation subclasses.

* UI for reverting to earlier versions: full AJAX baby.

* Record creator of page, deleter of page, editor of slot. 

* Show whodunnit when displaying an editable view of the page or slot.

* "Infinite slots" (areas).

* Custom slots.

Current revision should not be a preview choice

Update the metacontrols area itself on refreshes, or equivalent JS

Slot save should be AJAXed since we already manipulate slots via AJAX

Secure the AJAX actions for version control.

* * *

Notes on how global slots got done:

The idea is that global slots are not tied to a page. But that's going
to mess with my very page-based model API.

I could keep them in a special page with the slug 'global' (no / ).

But that's going to mess with my setCurrentPage()/getCurrentPage() stuff.

So I need to parameterize at least enough to make that safe and avoid
relentless assumptions that I can just call getCurrentPage(). Or I
could have a stack for getCurrentPage(). Which is actually a great
idea and will work just fine.

$realPage = getCurrentPage()
setCurrentPage(retrieveBySlug('global'))
if (global page does not exist) then
  create the global page
... include the area or slot ...
setCurrentPage($realPage)

* Can't see the new versions you've created by reverting to old versions
because you're not refreshing the dropdown on revert

* * *

A: 5
B: 6
C: 7

Revert to 6

Delete A: 8

Now C is baaaaack (7 < 8).

How can I fix this in a safe and reliable way?

When I revert I need to copy to a new version, and I need to do that
for every permid that has ever existed. If they don't exist
*as of the version being reverted to* then I need to represent
them as deleted permids.

All this copying is inefficient. 

What about this schema:

area_slot_version
  name
  version
  permid
  slot_id
  latest

Slots still have a permid also. They don't have a version.

Every time you make a new version of an area, area_slot_versions get created
for all of the slots in the area. They can point to old slots if they want to.

Deletion of a slot means there just isn't an area_slot_version 
for that slot permid in that version.

This has a lot of bennies, most importantly the fact that version
numbers become strictly consecutive thank you jeebuz. Also it works
gracefully with Doctrine.

I reverted to revision 5 from revision 10.

Then I edited slot B which brought that slot to revision 11.

Then I reverted to revision 2.

Then I reverted to revision 11 and some non-slot-B stuff
wasn't right. Why is that? Because revision 10 deleted
that other stuff. Ow.

Reverting really should copy everything. Why did I not want to 
do that? Because it could impose painful requirements on
custom slots that use foreign references.

I could require that foreign references be made from 
the aggregate inheritance subclass to the external class
and never the other way around. That way I can safely copy.
But I don't get VC of the aggregate inheritance subclass.
In fact there's no way I could get that anyway.

I could just say all versioned information must live
right in the column aggregation subclass. I like that. 
And I could offer helper methods if I really cared about
right in the column aggregation subclass. I like that.
And I could offer helper methods if I really cared about
helping people VC their external refs.




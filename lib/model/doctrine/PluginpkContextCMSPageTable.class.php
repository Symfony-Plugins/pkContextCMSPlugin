<?php
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PluginpkContextCMSPageTable extends Doctrine_Table
{
  // Is this the best place to keep snippets like this?

  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context
  static public function retrieveBySlug($slug, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    $query = new Doctrine_Query();
    $page = $query->
      from('pkContextCMSPage p')->
      where('p.slug = ?', $slug)->
      fetchOne();
    // In case Doctrine is clever and returns the same page object
    if ($page)
    {
      $page->clearSlotCache();
      $page->setCulture($culture);
    }
    return $page;
  }

  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context
  static public function retrieveBySlugWithTitles($slug, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    $query = self::queryWithTitles($culture);
    $page = $query->
      where('p.slug = ?', $slug)->
      fetchOne();
    // In case Doctrine is clever and returns the same page object
    if ($page)
    {
      $page->clearSlotCache();
      $page->setCulture($culture);
    }
    return $page;
  }
  
  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context
  static public function retrieveBySlugWithSlots($slug, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    $query = self::queryWithSlots(false, $culture);
    $page = $query->
      where('p.slug = ?', $slug)->
      fetchOne();
    // In case Doctrine is clever and returns the same page object
    if ($page)
    {
      $page->clearSlotCache();
      $page->setCulture($culture);
    }
    return $page;
  }
  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context

  static public function queryWithTitles($culture = null)
  {
    return self::queryWithSlot('title', $culture);
  }
  
  static public function queryWithSlot($slot, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    return Doctrine_Query::Create()->
      select("p.*, a.*, v.*, avs.*, s.*")->
      from("pkContextCMSPage p")->
      leftJoin('p.Areas a WITH (a.name = ? AND a.culture = ?)', array($slot, $culture))->
      leftJoin('a.AreaVersions v WITH (a.latest_version = v.version)')->
      leftJoin('v.AreaVersionSlots avs')->
      leftJoin('avs.Slot s');
  }
 
  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context

  static public function retrieveByIdWithSlots($id, $culture = null)
  {
    return self::retrieveByIdWithSlotsForVersion($id, false, $culture);
  }
  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context

  static public function retrieveByIdWithSlotsForVersion($id, $version, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    $page = self::queryWithSlots($version, $culture)->
      where('p.id = ?', array($id))->
      fetchOne();
    // In case Doctrine is clever and returns the same page object
    if ($page)
    {
      $page->clearSlotCache();
      // Thanks to Quentin Dugauthier for spotting that there were
      // still instances of this not being inside the if
      $page->setCulture($culture);
    }
    return $page;
  }

  // If culture is null you get the current user's culture,
  // or sf_default_culture if none is set or we're running in a task context

  static public function queryWithSlots($version = false, $culture = null)
  {
    if (is_null($culture))
    {
      $culture = pkContextCMSTools::getUserCulture();
    }
    $query = Doctrine_Query::Create()->
      select("p.*, a.*, v.*, avs.*, s.*")->
      from("pkContextCMSPage p")->
      leftJoin('p.Areas a WITH a.culture = ?', array($culture));
    if ($version === false)
    {
      $query = $query->
        leftJoin('a.AreaVersions v WITH (a.latest_version = v.version)');
    }
    else
    {
      $query = $query->
        leftJoin('a.AreaVersions v WITH (v.version = ?)', array($version));
    }
    return $query->leftJoin('v.AreaVersionSlots avs')->
      leftJoin('avs.Slot s')->
      orderBy('avs.rank asc');
  }
  
  static private $treeObject = null;
  
  static public function treeTitlesOn()
  {
    self::treeSlotOn('title');
  }
  
  static public function treeSlotOn($slot)
  {
    $query = pkContextCMSPageTable::queryWithSlot($slot);
    self::$treeObject = Doctrine::getTable('pkContextCMSPage')->getTree();
    // I'm not crazy about how I have to set the base query and then
    // reset it, instead of simply passing it to getChildren. A
    // Doctrine oddity
    self::$treeObject->setBaseQuery($query);
  }
  
  static public function treeTitlesOff()
  {
    self::treeSlotOff();
  }
  
  static public function treeSlotOff()
  {
    self::$treeObject->resetBaseQuery();
  } 
  
  public function getLuceneIndexFile()
  {
    return pkZendSearch::getLuceneIndexFile($this);
  }

  public function getLuceneIndex()
  {
    return pkZendSearch::getLuceneIndex($this);
  }

  public function rebuildLuceneIndex()
  {
    pkZendSearch::purgeLuceneIndex($this);
    $pages = $this->findAll();
    foreach ($pages as $page)
    {
      $cultures = array();
      foreach ($page->Areas as $area)
      {
        $cultures[$area->culture] = true; 
      }
      $cultures = array_keys($cultures);
      foreach ($cultures as $culture)
      {
        $cpage = self::retrieveByIdWithSlots($page->id, $culture);
        $cpage->updateLuceneIndex();
      }
    }
  }
  
  public function addSearchQuery(Doctrine_Query $q = null, $luceneQuery)
  {
    // Page searches are always specific to this user's culture
    $culture = pkContextCMSTools::getUserCulture();
    $luceneQuery = "+(text:($luceneQuery))";
    return pkZendSearch::addSearchQuery($this, $q, $luceneQuery, $culture);
  }
  
  public function addSearchQueryWithScores(Doctrine_Query $q = null, $luceneQuery, &$scores)
  {
    // Page searches are always specific to this user's culture
    $culture = pkContextCMSTools::getUserCulture();
    $luceneQuery = "+(text:($luceneQuery))";
    return pkZendSearch::addSearchQueryWithScores($this, $q, $luceneQuery, $culture, $scores);
  }
  
  // Just a hook used by the above
  public function searchLucene($query, $culture)
  {
    return pkZendSearch::searchLucene($this, $query, $culture);
  }
  
  // Just a hook used by the above
  public function searchLuceneWithScores($query, $culture)
  {
    return pkZendSearch::searchLuceneWithScores($this, $query, $culture);
  }

  // Returns engine page with the longest matching path.
  // We use a cache so that we don't wind up making separate queries
  // for every engine route in the application
  
  protected static $engineCacheUrl = false;
  protected static $engineCachePage = false;
  protected static $engineCacheRemainder = false;
  
  static public function getMatchingEnginePage($url, &$remainder)
  {
    if ($url === self::$engineCacheUrl)
    {
      $remainder = self::$engineCacheRemainder;
      return self::$engineCachePage;
    }
    $urls = array();
    $twig = $url;
    while (true)
    {
      if (($twig === '/') || (!strlen($twig)))
      {
        // Either we've been called for the home page, or we just
        // stripped the first slash and are now considering the home page
        $urls[] = '/';
        break;
      }
      $urls[] = $twig;
      if (!preg_match('/^(.*)\/[^\/]+$/', $twig, $matches))
      {
        break;
      }
      $twig = $matches[1];
    }
    $page = Doctrine_Query::create()->
      select('p.*, length(p.slug) as len')->
      from('pkContextCMSPage p')->
      whereIn('p.slug', $urls)->
      andWhere('p.engine IS NOT NULL')->
      orderBy('len desc')->
      limit(1)->
      fetchOne();
    self::$engineCachePage = $page;
    self::$engineCacheUrl = $url;
    self::$engineCacheRemainder = false;
    if ($page)
    {
      $remainder = substr($url, strlen($page->slug));
      self::$engineCacheRemainder = $remainder;
      return $page;
    }
    return false;
  }
  
  // Used when generating an engine link from a page other than the engine page itself.
  // Many engines are only placed in one location per site, so this is often reasonable
  static public function getFirstEnginePage($engine)
  {
    $page = Doctrine_Query::create()->
     from('pkContextCMSPage p')->
     where('p.engine = ?', array($engine))->
     limit(1)->
     fetchOne();
    return $page;
  }
}

<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginpkContextCMSPage extends BasepkContextCMSPage
{
  const NEXT_PERMID = -1;
  public $culture;
  public $privileges;
  // Not a typo. Doctrine calls construct() for you as an alternative
  // to __construct(), which it won't let you override.
  public function construct()
  {
    $this->culture = pkContextCMSTools::getUserCulture();
    $this->privileges = array();
  }
  private function log($message)
  {
    sfContext::getInstance()->getLogger()->info("PAGE: $message");
  }

  // Note: for best performance don't pass the user explicitly
  // unless it's NOT the current user.

  public function userHasPrivilege($privilege, $user = false)
  {
    if ($privilege === 'delete')
    {
      // If you can EDIT the parent, then you can DELETE
      // its children (after all, you could create them).
      $parent = $this->getParent();
      if (!$parent)
      {
        // Nobody, not even the superadmin, can delete the home page
        return false;
      }
      return $parent->userHasPrivilege('edit');
    }

    // Caching for speed when answering the same query about the
    // current user over and over again during the lifetime of
    // a single request (to check editing privs on slots etc)
    if ($user === false)
    {
        $user = sfContext::getInstance()->getUser();
      if (!isset($this->privileges[$privilege]))
      {
        $this->privileges[$privilege] = $this->userHasPrivilegeBody(
          $privilege, $user);
      }
      return $this->privileges[$privilege];
    }
    else
    {
      // If we're asking about a specific user we presumably have
      // something less frequent in mind
      $this->userHasPrivilegeBody(
        $privilege, $user);
    }
  }

  protected function userHasPrivilegeBody($privilege, $user)
  {
    // Rule 1: admin can do anything
    if ($user->hasCredential('cms_admin'))
    {
      $this->log("has cms_admin");
      return true;
    }
    $key = "app_pkContextCMS_$privilege" . "_sufficient_credentials";
    $this->log("KEY IS $key");
    $sufficientCredentials = sfConfig::get(
        "app_pkContextCMS_$privilege" . "_sufficient_credentials", false);
    $sufficientGroup = sfConfig::get(
        "app_pkContextCMS_$privilege" . "_sufficient_group", false);
    $candidateGroup = sfConfig::get(
        "app_pkContextCMS_$privilege" . "_candidate_group", false);
    // By default users must log in to do anything except view
    $loginRequired = sfConfig::get(
        "app_pkContextCMS_$privilege" . "_login_required", 
        ($privilege === 'view' ? false : true));

    // Rule 2: if no login is required for the site as a whole for this
    // privilege, anyone can do it...
    if (!$loginRequired)
    {
      $this->log("login not required");
      // Except for rule 2a: individual pages can be conveniently locked for 
      // viewing purposes on an otherwise public site
      if (($privilege === 'view') && $this->view_is_secure)
      {
        $this->log("however this page requires login and we are viewing");
        return $user->isAuthenticated();
      } 
      else
      {
        $this->log("so in we go");
        return true;
      }
    }

    // Corollary of rule 2: if login IS required and you're not
    // logged in, bye-bye
    if (!$user->isAuthenticated())
    {
      $this->log("not authenticated, fail");
      return false;
    }

    // Rule 3: if there are no sufficient credentials and there is no
    // required or sufficient group, then login alone is sufficient. Common 
    // on sites with one admin
    if (($sufficientCredentials === false) && ($candidateGroup === false) && ($sufficientGroup === false))
    {
      // Logging in is the only requirement
      $this->log("no required group, no sufficient credentials, we're in");
      return true; 
    }

    // Rule 4: if the user has sufficient credentials... that's sufficient!
    // Many sites will want to simply say 'editors can edit everything' etc
    if ($sufficientCredentials && 
      ($user->hasCredential($sufficientCredentials)))
    {
      $this->log("user has sufficient credentials");
      return true;
    }
    if ($sufficientGroup && 
      ($user->hasGroup($sufficientGroup)))
    {
      $this->log("user is in sufficient group");
      return true;
    }

    // Rule 5: if there is a candidate group, make sure the user is a member
    // before checking for explicit privileges for that user
    if ($candidateGroup && 
      (!$user->hasGroup($candidateGroup)))
    {
      $this->log("user not in candidate group");
      return false;
    }

    // Rule 6: when minimum but not sufficient credentials are present,
    // check for an explicit grant of privileges to this user, on
    // this page or on any ancestor page.
    $result = $this->userHasExplicitPrivilege($privilege);
    $this->log("Explicit privilege for user: $result\n");
    return $result;
  }

  private function userHasExplicitPrivilege($privilege)
  {
    // Use caching proxy implementation
    $ancestors = $this->getAncestors(); 
    $ids = array();
    foreach ($ancestors as $page)
    {
      $ids[] = $page->id;
    }
    $this->log("Ancestor count: " . count($ids) . " page id: " . $this->id);
    $ids[] = $this->id;
    $this->log("Ancestors are: " . implode(",", $ids));
    $user_id = sfContext::getInstance()->getUser()->getGuardUser()->getId();
    // One "yes" answer is enough.
    $result = Doctrine_Query::create()->
      from('pkContextCMSAccess a')->
      where("a.page_id IN (" . implode(",", $ids) . ") AND " .
        "a.user_id = $user_id AND a.privilege = ?", array($privilege))->
      limit(1)->
      execute();
    return (count($result) > 0);
  }

  // The new API:
  //
  // getArea(name)
  // newAreaVersion(name, action, params)
 

  private $slotCache = false;
  private function populateSlotCache()
  {
    if ($this->slotCache === false)
    {
      $this->slotCache = array();
      // We have $this->Areas courtesy of whatever query
      // fetched the page in the first place
      foreach ($this->Areas as $area)
      {
        $areaVersion = $area->AreaVersions[0];
        foreach ($areaVersion->AreaVersionSlots as $areaVersionSlot)
        {
          $slot = $areaVersionSlot->Slot;
          $this->slotCache[$this->culture][$area->name][$areaVersionSlot->permid] = $slot;
        }
      }
    }
  }
  public function hasSlot($name, $permid = 1)
  {
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture][$name][$permid]))
    {
      return true;
    }
    return false;
  }
  public function getSlot($name, $permid = 1)
  {
    if ($this->hasSlot($name, $permid))
    {
      return $this->slotCache[$this->culture][$name][$permid];
    }
    return false;
  }
  public function getArea($name)
  {
    $this->populateSlotCache();
    $results = array();
    if (isset($this->slotCache[$this->culture][$name]))
    {
      foreach ($this->slotCache[$this->culture][$name] as $permid => $slot)
      {
        $results[$permid] = $slot;
      }
    }
    return $results;
  }

  public function getNextPermidAndRank($name)
  {
    $query = Doctrine_Query::create()->
        select('max(s.permid) as m, max(s.rank) as r')->
        from('pkContextCMSArea a')->
        leftJoin('a.AreaVersions v')->
        leftJoin('v.AreaVersionSlots s')->
        where('a.name = ? AND a.page_id = ?', array($name, $this->id));
    $result = $query->execute();
         
    if (isset($result[0]['m']))
    {
      $permid = $result[0]['m'] + 1;
    }
    else
    {
      $permid = 1;
    }
    if (isset($result[0]['r']))
    {
      $rank = $result[0]['r'] + 1;  
    }
    else
    {
      $rank = 1;
    }
    return array(
      'permid' => $permid, 
      'rank' => $rank);
  }

  public function createSlot($type)
  {
    $class = $type . "Slot";
    $slot = new $class;
    $slot->type = $type;
    return $slot;
  }

  public function getTitle()
  {
    $titleSlot = $this->getSlot('title');
    if ($titleSlot)
    {
      $result = $titleSlot->value;
    }
    else
    {
      $result = '';
    }
    $title = trim($result);
    if (!strlen($result))
    {
      // Don't break the UI, return something reasonable
      $slug = $this->slug;
      $title = substr(strrchr($slug, "/"), 1);
      if (!strlen($title))
      {
        $title = "Home";
      }
    }
    return $title;
  }

  public function getAreaVersions($name)
  {
    $results = Doctrine_Query::create()->
      from("pkContextCMSArea a")->
      leftJoin("a.AreaVersions v")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      orderBy("v.version asc")->
      execute();
    $last = false;
    $versions = array();
    $area = $results[0];
    foreach ($area->AreaVersions as $areaVersion)
    {
      $versions[$areaVersion->version] = 
        $areaVersion->created_at . " " . ($areaVersion->Author ? 
            $areaVersion->Author->username : "NONE");
    }
    return $versions;
  }

  public function getAreaCurrentVersion($name)
  {
    $area = Doctrine_Query::create()->
      from("pkContextCMSArea a")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      fetchOne();
    if ($area)
    {
      return $area->latest_version;
    }
    return 0;
  }

  private $childrenCache = null;
  private $childrenCacheLivingOnly = null;
  // Returns an array even when there are zero children.
  // Who in the world wants to special case that as if it
  // were the end of the world?
  public function getChildren($livingOnly = true)
  {
    if ($this->childrenCache !== null)
    {
      if ($livingOnly === $this->childrenCacheLivingOnly)
      {
        return $this->childrenCache;
      }
    }
    $this->childrenCacheLivingOnly = $livingOnly;
    // TODO: consider whether it's possible to get the base query to
    // exclude archived children. That would result in multiple
    // calls to where(), but perhaps Doctrine can combine them for us.
    pkContextCMSPageTable::treeTitlesOn();
    $children = $this->getNode()->getChildren();
    pkContextCMSPageTable::treeTitlesOff();
    if ($children !== false)
    {
      $living = array();
      $dead = array();
      foreach ($children as $child)
      {
        if ($child->archived)
        {
          $dead[] = $child;
        }
        else
        {
          $living[] = $child;
        }
      }
      if ($livingOnly)
      {
        $children = $living;
      }
      else
      {
        $children = array_merge($living, $dead);
      }
    }
    else
    {
      $children = array();
    }
    $this->childrenCache = $children;
    return $children;
  }
  public function hasChildren($livingOnly = true)
  {
    // not as inefficient as it looks because of the caching feature
    return (count($this->getChildren($livingOnly)) != 0);
  }

  public function getUrl()
  {
    return pkContextCMSTools::urlForPage($this->getSlug());
  }

  private $ancestorsCache = false;
  public function getAncestors()
  {
    if ($this->ancestorsCache !== false)
    {
      return $this->ancestorsCache;
    } 
    pkContextCMSPageTable::treeTitlesOn();
    $this->ancestorsCache = $this->getNode()->getAncestors();
    pkContextCMSPageTable::treeTitlesOff();
    if ($this->ancestorsCache === false)
    {
      // Empty lists are not evil!
      $this->ancestorsCache = array();
    }
    return $this->ancestorsCache;
  }
  public function isEqualTo($page)
  {
    return ($page->getSlug() === $this->getSlug());
  }

  public function begin()
  {
    $conn = Doctrine_Manager::connection();
    $conn->beginTransaction();
  }

  public function end()
  {
    $conn = Doctrine_Manager::connection();
    $conn->commit();
  }

  public function setTitle($title)
  {
    $slot = $this->createSlot('pkContextCMSText');
    $slot->value = htmlspecialchars($title);
    $slot->save();
    $this->newAreaVersion('title', 'update', 
      array(
        'permid' => 1, 
        'slot' => $slot));
  }

  public function newAreaVersion($name, $action, $params = false)
  {
    if ($params === false)
    {
      $params = array();
    }
    $this->begin();
    // We use the slots already queried as a basis for the new version,
    // because that makes rollback easy to implement etc. But we
    // MUST fetch the latest copy of the area object to make sure
    // we don't create duplicate versions.
    $newSlots = $this->getArea($name);
    $area = pkContextCMSAreaTable::retrieveOrCreateByPageIdAndName(
      $this->id,
      $name);
    if (!$area->id)
    {
      // We need an ID established
      $area->save();
    }
    $areaVersion = new pkContextCMSAreaVersion();
    $areaVersion->area_id = $area->id;
    $areaVersion->version = $area->latest_version + 1;
    $areaVersion->author_id = 
      sfContext::getInstance()->getUser()->getGuardUser()->getId();
    $areaVersion->save();
    $newSlots = $this->getArea($name);
    if ($action === 'delete')
    {
      if (isset($newSlots[$params['permid']]))
      {
        unset($newSlots[$params['permid']]);
      }
    }
    elseif ($action === 'update')
    {
      $newSlots[$params['permid']] = $params['slot']; 
    }
    elseif ($action === 'add')
    {
      // Make sure we get a truly unique permid within this slot
      $permidAndRank = $this->getNextPermidAndRank($name);
      $newSlots[$permidAndRank['permid']] = $params['slot'];
    }
    elseif ($action === 'sort')
    {
      $newerSlots = array();
      foreach ($params['permids'] as $permid)
      {
        $newerSlots[$permid] = $newSlots[$permid];
      }
      $newSlots = $newerSlots;
    }
    elseif ($action === 'revert')
    {
      # We just want whatever is in the slot cache copied to a new version
    }

    $rank = 1;
    foreach ($newSlots as $permid => $slot)
    {
      // After unset, foreach shows keys but has null values
      if (!$slot)
      {
        continue;
      }
      $areaVersionSlot = new pkContextCMSAreaVersionSlot();
      $areaVersionSlot->slot_id = $slot->id;
      $areaVersionSlot->permid = $permid;
      $areaVersionSlot->area_version_id = $areaVersion->id;
      $areaVersionSlot->rank = $rank++;
      $areaVersionSlot->save();
    }
    $area->latest_version++;
    $area->save();
    $this->end();
  }
  public function clearSlotCache()
  {
    $this->slotCache = false;
  }
  public function getAccessesById($privilege)
  {
    $candidateGroup = sfConfig::get('app_pkContextCMS_' . $privilege . '_candidate_group', false);
    $sufficientGroup = sfConfig::get('app_pkContextCMS_' . $privilege . '_sufficient_group', false);
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $withClauses = array();
    $withParameters = array();
    if ($candidateGroup)
    {
      $candidateGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($candidateGroup);
      if (!$candidateGroup)
      {
        throw new Exception("Candidate group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $candidateGroup->id;
    }
    if ($sufficientGroup)
    {
      $sufficientGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($sufficientGroup);
      if (!$sufficientGroup)
      {
        throw new Exception("Sufficient group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $sufficientGroup->id;
    }
    if (count($withClauses))
    {
      $query->innerJoin("u.groups g with " . implode(" OR ", $withClauses),
        $withParameters);
    } 
    $query->orderBy("u.username asc");
    $this->log($query->getSql());
    $allResults = $query->execute();
    $all = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->username;
      if ($sufficientGroup && ($actor->hasGroup($sufficientGroup->getName())))
      {
        $sufficient[] = $actor->id;
      }
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("u.Accesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("u.username asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $user)
    {
      foreach ($user->Accesses as $access)
      {
        if (!isset($found[$user->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $user->id;
            $found[$user->id] = true;
          }
          else
          {
            $selected[] = $user->id;
            $found[$user->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited, $sufficient);
  }
  public function setAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    $query->from('pkContextCMSAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new pkContextCMSAccess();
      $access->user_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }
 
  private $parentCache = false;
  public function getParent()
  {
    if ($this->parentCache === false)
    {
      $this->parentCache = $this->getNode()->getParent();
    }
    return $this->parentCache;
  }
}
